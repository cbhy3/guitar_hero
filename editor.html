<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Guitar Hero - Chart Editor</title>
  <style>
    :root{--bg:#111;--lane:#222;--accent:#0aa;--hit:#444;--panel:#0f1720}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071017,#0b1220);color:#ddd;font-family:Inter,Segoe UI,Arial,sans-serif}
    .app{display:grid;grid-template-columns:1fr 340px;gap:12px;height:100vh;padding:12px}
    .canvas-wrap{background:var(--panel);border-radius:12px;padding:12px;display:flex;flex-direction:column}
    canvas{background:var(--lane);border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    .controls{display:flex;gap:8px;align-items:center;padding-top:8px}
    button{background:#0b1320;color:#cfe; border:1px solid #233;padding:8px 10px;border-radius:8px;cursor:pointer}
    button.active{outline:3px solid rgba(10,170,170,0.12)}
    .panel{background:linear-gradient(180deg,#081018,#071218);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px}
    .group{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
    label{display:block;font-size:12px;color:#9aa}
    input[type=range]{width:100%}
    input[type=number], input[type=text], select{width:100%;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#ddd}
    .row{display:flex;gap:8px}
    pre{white-space:pre-wrap;max-height:220px;overflow:auto;background:#0002;padding:8px;border-radius:8px}
    .tools{display:flex;gap:6px}
    .small{font-size:12px;padding:6px 8px}
    .muted{color:#7b8}
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <canvas id="game" width="900" height="600"></canvas>
      <div class="controls">
        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="stopBtn">Stop</button>
        <div style="width:600px">
          <input id="timeSlider" type="range" min="0" max="120" step="0.001" value="0">
        </div>
            <label>Speed:
        <input id="speedSlider" type="range" min="0.5" max="2" step="0.05" value="1">
        <span id="speedValue">1.00x</span>
        </label>
        <div style="flex:1;text-align:right;color:#9aa;font-size:13px" id="timeDisplay">0.000s</div>
      </div>
      <div class="controls">
        <div class="tools">
          <button id="toolSelect" class="active small">Select</button>
          <button id="toolTap" class="small">Add Tap</button>
          <button id="toolHold" class="small">Add Hold</button>
          <button id="snapBtn" class="small">Snap: off</button>
        </div>
        <div style="flex:1"></div>
        <div class="muted">Tip: click canvas to add, drag vertically to set time, drag horizontally to change lane.</div>
      </div>
    </div>

    <div class="panel">
      <div class="group">
        <label>Load audio (or set URL)</label>
        <input id="audioUrl" type="text" placeholder="/audio/song.mp3" />
        <div style="display:flex;gap:8px;margin-top:6px">
          <input id="fileAudio" type="file" accept="audio/*">
          <button id="loadAudio" class="small">Load URL</button>
        </div>
        <label style="margin-top:8px">BPM</label>
        <input id="bpm" type="number" step="0.1" value="120">
      </div>

      <div class="group">
        <label>Chart I/O</label>
        <div style="display:flex;gap:6px;margin-bottom:8px">
          <input id="fileChart" type="file" accept="application/json">
          <button id="exportBtn" class="small">Export JSON</button>
        </div>
        <pre id="jsonOut">(chart JSON will appear here)</pre>
      </div>

      <div class="group">
        <label>Selected Note</label>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">
          <div>
            <label>Type</label>
            <select id="selType"><option value="tap">tap</option><option value="hold">hold</option></select>
          </div>
          <div>
            <label>Lane</label>
            <input id="selLane" type="number" min="0" max="4" step="1">
          </div>
          <div style="grid-column:1/3">
            <label>Time (s)</label>
            <input id="selTime" type="number" step="0.001">
          </div>
          <div style="grid-column:1/3">
            <label>Duration (hold only)</label>
            <input id="selDur" type="number" step="0.001">
          </div>
        </div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="deleteNote" class="small">Delete</button>
          <button id="nudgeLeft" class="small">-0.050s</button>
          <button id="nudgeRight" class="small">+0.050s</button>
        </div>
      </div>

      <div class="group">
        <label>Editor Settings</label>
        <div class="row" style="margin-top:8px">
          <label style="flex:1">Lanes <input id="lanes" type="number" min="1" max="10" value="5"></label>
          <label style="flex:1">Lookahead <input id="lookahead" type="number" step="0.1" value="1.5"></label>
        </div>
        <div style="display:flex;gap:6px;margin-top:8px">
          <button id="resetBtn" class="small">Reset Notes</button>
          <button id="snapToGrid" class="small">Snap to grid now</button>
        </div>
      </div>

    </div>
  </div>

  <script>
  (async function(){
    // --- Core state ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let lanes = parseInt(document.getElementById('lanes').value, 10);
    let laneWidth = canvas.width / lanes;
    const hitY = canvas.height - 100;

    let bpm = parseFloat(document.getElementById('bpm').value) || 120;
    let lookahead = parseFloat(document.getElementById('lookahead').value) || 1.5;

    let pixelsPerSecond = 400 * (bpm / 100); // base scrollSpeed * (bpm/100)
    const baseScrollSpeed = 400;

    // editor data
    let notes = []; // {time, type:'tap'|'hold', lane, duration?, judged?, hit?, holding?, released?, hold_success?}

    // audio
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let audioBuffer = null; // decoded buffer
    let audioStartTime = null; // audioContext.currentTime when playback started
    let srcNode = null;
    let isPlaying = false;

    // UI refs
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const timeSlider = document.getElementById('timeSlider');
    const timeDisplay = document.getElementById('timeDisplay');
    const toolSelect = document.getElementById('toolSelect');
    const toolTap = document.getElementById('toolTap');
    const toolHold = document.getElementById('toolHold');
    const snapBtn = document.getElementById('snapBtn');
    const audioUrl = document.getElementById('audioUrl');
    const loadAudio = document.getElementById('loadAudio');
    const fileAudio = document.getElementById('fileAudio');
    const bpmInput = document.getElementById('bpm');
    const exportBtn = document.getElementById('exportBtn');
    const jsonOut = document.getElementById('jsonOut');
    const selType = document.getElementById('selType');
    const selLane = document.getElementById('selLane');
    const selTime = document.getElementById('selTime');
    const selDur = document.getElementById('selDur');
    const deleteNote = document.getElementById('deleteNote');
    const nudgeLeft = document.getElementById('nudgeLeft');
    const nudgeRight = document.getElementById('nudgeRight');
    const fileChart = document.getElementById('fileChart');
    const resetBtn = document.getElementById('resetBtn');
    const snapToGridBtn = document.getElementById('snapToGrid');
    const speedSlider = document.getElementById("speedSlider");
    const speedValue  = document.getElementById("speedValue");

    speedSlider.addEventListener("input", () => {
    speedValue.textContent = speedSlider.value + "x";
    });
    // editor interaction
    let currentTool = 'select'; // select | tap | hold
    let snap = false;
    let selectedNote = null;
    let dragging = false;
    let dragMode = null; // 'move'|'create'
    let createTemp = null; // temporary note while dragging
    let dragOffsetTime = 0;
    let initialMouse = null;

    function setTool(t){
      currentTool = t;
      [toolSelect,toolTap,toolHold].forEach(b => b.classList.remove('active'));
      if (t==='select') toolSelect.classList.add('active');
      if (t==='tap') toolTap.classList.add('active');
      if (t==='hold') toolHold.classList.add('active');
    }

    toolSelect.onclick = () => setTool('select');
    toolTap.onclick = () => setTool('tap');
    toolHold.onclick = () => setTool('hold');

    document.getElementById('snapBtn').onclick = () => {
      snap = !snap;
      snapBtn.textContent = 'Snap: ' + (snap ? 'on' : 'off');
    }

    // update lane count and derived values
    document.getElementById('lanes').addEventListener('input', (e)=>{
      lanes = Math.max(1, parseInt(e.target.value,10)||5);
      laneWidth = canvas.width / lanes;
    });

    document.getElementById('bpm').addEventListener('input', e=>{
      bpm = parseFloat(e.target.value) || 120;
      pixelsPerSecond = baseScrollSpeed * (bpm/100);
    });

    document.getElementById('lookahead').addEventListener('input', e=>{
      lookahead = parseFloat(e.target.value) || 1.5;
    });

    // --- audio load / play control ---
    async function decodeArrayBuffer(ab){
      return await audioContext.decodeAudioData(ab.slice(0));
    }

    loadAudio.onclick = async ()=>{
      const url = audioUrl.value.trim();
      if (!url) return alert('enter audio url');
      try{
        const r = await fetch(url);
        const ab = await r.arrayBuffer();
        audioBuffer = await decodeArrayBuffer(ab);
        alert('audio loaded');
        timeSlider.max = Math.max(10, audioBuffer.duration.toFixed(3));
      }catch(err){alert('failed to load audio: '+err.message)}
    }

    fileAudio.onchange = async (e)=>{
      const f = e.target.files[0];
      if (!f) return;
      const ab = await f.arrayBuffer();
      audioBuffer = await decodeArrayBuffer(ab);
      timeSlider.max = Math.max(10, audioBuffer.duration.toFixed(3));
      audioUrl.value = f.name;
    }

    function startAudioAt(time){
      if (!audioBuffer) return;
      if (srcNode) try{srcNode.stop()}catch(_){}
      srcNode = audioContext.createBufferSource();
      srcNode.buffer = audioBuffer;
      srcNode.connect(audioContext.destination);
      audioStartTime = audioContext.currentTime - time;
      const rate = parseFloat(speedSlider.value);   // or speedSelect.value
      srcNode.playbackRate.value = rate;
      srcNode.start(0, time);
      isPlaying = true;
    }

    playBtn.onclick = async ()=>{
      if (!audioBuffer) return alert('Load an audio file first');
      if (audioContext.state === 'suspended') await audioContext.resume();
      const t = parseFloat(timeSlider.value) || 0;
      startAudioAt(t);
    }

    pauseBtn.onclick = ()=>{
      if (!isPlaying) return;
      // stop playback but keep slider position
      if (srcNode) try{srcNode.stop()}catch(_){}
      isPlaying = false;
      // audioStartTime remains used as reference; we'll set to null to indicate paused
      audioStartTime = null;
    }

    stopBtn.onclick = ()=>{
      if (srcNode) try{srcNode.stop()}catch(_){}
      isPlaying = false;
      audioStartTime = null;
      timeSlider.value = 0;
    }

    timeSlider.addEventListener('input', ()=>{
      timeDisplay.textContent = parseFloat(timeSlider.value).toFixed(3) + 's';
      if (isPlaying){
        // restart audio at new time
        startAudioAt(parseFloat(timeSlider.value));
      } else {
        // when paused, we just update editor time
      }
    });

    // load/export chart
    fileChart.onchange = (e)=>{
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const obj = JSON.parse(reader.result);
          if (Array.isArray(obj.notes)){
            notes = obj.notes.map(n=>({...n, judged:false, hit:false, holding:false, released:false, hold_success:false}));
            if (obj.bpm) {bpm = obj.bpm; bpmInput.value = bpm; pixelsPerSecond = baseScrollSpeed*(bpm/100)}
            jsonOut.textContent = 'Imported ' + notes.length + ' notes';
          } else {
            alert('invalid chart file')
          }
        }catch(err){alert('parse error: '+err.message)}
      }
      reader.readAsText(f);
    }

    exportBtn.onclick = ()=>{
      const out = { audio: audioUrl.value || '', bpm: bpm, notes: notes.map(n => {
        const o = { time: +n.time.toFixed(3), type: n.type, lane: n.lane };
        if (n.type === 'hold') o.duration = +n.duration.toFixed(3);
        return o;
      }).sort((a,b)=>a.time-b.time) };
      const json = JSON.stringify(out, null, 2);
      jsonOut.textContent = json;
      // download
      const blob = new Blob([json], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'chart.json'; a.click(); URL.revokeObjectURL(url);
    }

    // selection panel bindings
    function updateSelectionPanel(){
      if (!selectedNote){ selType.disabled = true; selLane.disabled = true; selTime.disabled = true; selDur.disabled = true; return; }
      selType.disabled = false; selLane.disabled = false; selTime.disabled = false; selDur.disabled = (selectedNote.type !== 'hold');
      selType.value = selectedNote.type;
      selLane.value = selectedNote.lane;
      selTime.value = selectedNote.time.toFixed(3);
      selDur.value = (selectedNote.duration||0).toFixed(3);
    }

    selType.onchange = ()=>{
      if (!selectedNote) return;
      selectedNote.type = selType.value;
      if (selectedNote.type === 'hold' && !selectedNote.duration) selectedNote.duration = 0.5;
      updateSelectionPanel();
    }
    selLane.oninput = ()=>{ if (!selectedNote) return; selectedNote.lane = Math.max(0, Math.min(lanes-1, parseInt(selLane.value)||0)); }
    selTime.oninput = ()=>{ if (!selectedNote) return; selectedNote.time = Math.max(0, parseFloat(selTime.value)||0); }
    selDur.oninput = ()=>{ if (!selectedNote) return; selectedNote.duration = Math.max(0, parseFloat(selDur.value)||0); }

    deleteNote.onclick = ()=>{ if (!selectedNote) return; notes = notes.filter(n=>n!==selectedNote); selectedNote = null; updateSelectionPanel(); }
    nudgeLeft.onclick = ()=>{ if (!selectedNote) return; selectedNote.time = Math.max(0, selectedNote.time - 0.05); updateSelectionPanel(); }
    nudgeRight.onclick = ()=>{ if (!selectedNote) return; selectedNote.time = Math.max(0, selectedNote.time + 0.05); updateSelectionPanel(); }

    resetBtn.onclick = ()=>{ if (!confirm('Clear all notes?')) return; notes = []; selectedNote = null; jsonOut.textContent = '(cleared)'; }

    snapToGridBtn.onclick = ()=>{ // snap all notes to nearest 1/32 beat by default
      const beat = 60 / bpm;
      const snapDiv = beat / 4; // 16th by default
      notes.forEach(n => {
        const q = Math.round(n.time / snapDiv);
        n.time = +(q * snapDiv).toFixed(3);
        if (n.type === 'hold' && n.duration) n.duration = +Math.max(0.02, Math.round(n.duration / snapDiv) * snapDiv).toFixed(3);
      });
    }

    // --- mouse interactions on canvas ---
    function canvasToLocal(e){
  const r = canvas.getBoundingClientRect();
  // client coords (CSS pixels)
  const cssX = e.clientX - r.left;
  const cssY = e.clientY - r.top;
  // convert to canvas coordinate space (handles HiDPI / css scaling)
  const x = cssX * (canvas.width / r.width);
  const y = cssY * (canvas.height / r.height);
  return {x, y};
}


    function posToLane(x){
      return Math.min(lanes-1, Math.max(0, Math.floor(x / laneWidth)));
    }

    function posToTime(y){
      // top of canvas -> far future, hitY -> 0 (time reference)
      const now = (isPlaying && audioStartTime !== null) ? (audioContext.currentTime - audioStartTime) : parseFloat(timeSlider.value) || 0;
      const dt = (hitY - y) / pixelsPerSecond; // seconds ahead of now
      return Math.max(0, now + dt);
    }

    function pickNoteAt(x, y) {
  const now = (isPlaying && audioStartTime !== null)
    ? (audioContext.currentTime - audioStartTime)
    : parseFloat(timeSlider.value) || 0;

  let best = null;
  let bestDist = Infinity;

  // sizes (tweak these if you like)
  const headRadius = 20;    // clickable radius for heads
  const tailRadius = 12;    // clickable radius for tail ends
  const bodyHalfWidth = 10; // rectangular width for hold body hit test

  for (const n of notes) {
    const noteY = hitY - (n.time - now) * pixelsPerSecond;
    const laneX = n.lane * laneWidth + laneWidth / 2;
    const dx = x - laneX;
    const dy = y - noteY;
    const distHead = Math.hypot(dx, dy);

    // If it's a tap note: head only
    if (n.type === 'tap') {
      if (distHead < headRadius && distHead < bestDist) {
        best = n;
        bestDist = distHead;
      }
      continue;
    }

    // If it's a hold: consider head, tail, and body rectangle
    const endTime = n.time + (n.duration || 0);
    const yEnd = hitY - (endTime - now) * pixelsPerSecond;

    // 1) head
    if (distHead < headRadius && distHead < bestDist) {
      best = n;
      bestDist = distHead;
    }

    // 2) tail end
    const dxTail = x - laneX;
    const dyTail = y - yEnd;
    const distTail = Math.hypot(dxTail, dyTail);
    if (distTail < tailRadius && distTail < bestDist) {
      best = n;
      bestDist = distTail;
    }

    // 3) body rectangle hit: check if x close to lane center and y between head and tail
    const minY = Math.min(noteY, yEnd) - 1;
    const maxY = Math.max(noteY, yEnd) + 1;
    if (Math.abs(dx) <= bodyHalfWidth && y >= minY && y <= maxY) {
      // treat body hits as close (distance = small)
      const pseudoDist = Math.abs(dx); // smaller dx -> better
      if (pseudoDist < bestDist) {
        best = n;
        bestDist = pseudoDist;
      }
    }
  }

  return best; // either a note object or null
}



    canvas.addEventListener('mousedown', (e)=>{
      const p = canvasToLocal(e);
      initialMouse = p;
      
      console.log('mouse local:', p);
  // print all visible notes' positions (first 10 to avoid spam)
  const now = (isPlaying && audioStartTime !== null) ? (audioContext.currentTime - audioStartTime) : parseFloat(timeSlider.value) || 0;
  for (let i=0;i<Math.min(notes.length, 20); i++){
    const n = notes[i];
    const y = hitY - (n.time - now) * pixelsPerSecond;
    const x = n.lane * laneWidth + laneWidth/2;
    console.log(i, n.type, 'lane', n.lane, 'time', n.time.toFixed(3), 'pos', {x: +x.toFixed(1), y: +y.toFixed(1)});
  }
  const clickedNote = pickNoteAt(p.x,p.y);
  console.log('pickNoteAt ->', clickedNote);
      if (currentTool === 'select'){
        if (clickedNote){ selectedNote = clickedNote; updateSelectionPanel(); dragging = true; dragMode='move';
          // compute time offset
          const now = (isPlaying && audioStartTime !== null) ? (audioContext.currentTime - audioStartTime) : parseFloat(timeSlider.value) || 0;
          dragOffsetTime = selectedNote.time - posToTime(p.y);
        } else { selectedNote = null; updateSelectionPanel(); }
      } else if (currentTool === 'tap'){
        // create tap at clicked time
        const lane = posToLane(p.x);
        const t = posToTime(p.y);
        const note = { lane, type:'tap', time: snap ? snapTimeToGrid(t) : +t.toFixed(3), judged:false, hit:false };
        notes.push(note); selectedNote = note; updateSelectionPanel(); dragging=false; createTemp=null;
      } else if (currentTool === 'hold'){
        // start creating hold note; drag to set duration
        const lane = posToLane(p.x);
        const start = posToTime(p.y);
        createTemp = { lane, type:'hold', time: start, duration: 0.05 };
        dragging = true; dragMode='create';
      }
    });

    canvas.addEventListener('mousemove', (e)=>{
      const p = canvasToLocal(e);
      if (!dragging) return;
      if (dragMode === 'move' && selectedNote){
        // move selected note with mouse
        const newLane = posToLane(p.x);
        selectedNote.lane = newLane;
        const t = posToTime(p.y) + dragOffsetTime;
        selectedNote.time = snap ? snapTimeToGrid(t) : Math.max(0, +t.toFixed(3));
        updateSelectionPanel();
      }
      if (dragMode === 'create' && createTemp){
        const end = posToTime(p.y);
        createTemp.duration = Math.max(0.02, (end - createTemp.time));
      }
    });

    canvas.addEventListener('mouseup', (e)=>{
      const p = canvasToLocal(e);
      if (dragMode === 'create' && createTemp){
        // finalize hold
        if (createTemp.duration <= 0.02){
          // treat as tap
          const t = createTemp.time;
          notes.push({lane:createTemp.lane, type:'tap', time: snap ? snapTimeToGrid(t) : +t.toFixed(3)});
        } else {
          const n = {lane:createTemp.lane, type:'hold', time: snap ? snapTimeToGrid(createTemp.time) : +createTemp.time.toFixed(3), duration: snap ? snapDurationToGrid(createTemp.duration) : +createTemp.duration.toFixed(3)};
          notes.push(n);
          selectedNote = n;
        }
        createTemp = null;
      }
      dragging = false; dragMode = null; updateSelectionPanel();
      canvas.dispatchEvent(new Event('redraw'));
    });

    canvas.addEventListener('dblclick', (e)=>{
      const p = canvasToLocal(e);
      const clicked = pickNoteAt(p.x,p.y);
      if (clicked){ selectedNote = clicked; updateSelectionPanel(); }
    });

    function snapTimeToGrid(t){
      // snap to 16th note by default
      const beat = 60 / bpm;
      const snapDiv = beat / 4; // 16th
      return +(Math.round(t / snapDiv) * snapDiv).toFixed(3);
    }
    function snapDurationToGrid(d){
      const beat = 60 / bpm;
      const snapDiv = beat / 4;
      return +(Math.max(0.02, Math.round(d / snapDiv) * snapDiv)).toFixed(3);
    }

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if (e.key === 'Delete' || e.key === 'Backspace') { if(selectedNote){ notes = notes.filter(n=>n!==selectedNote); selectedNote = null; updateSelectionPanel(); } }
      if (e.key === '1') setTool('select');
      if (e.key === '2') setTool('tap');
      if (e.key === '3') setTool('hold');
      if (e.key === ' ') { e.preventDefault(); if (isPlaying) { pauseBtn.click(); } else { playBtn.click(); } }
      const step = 0.25; // seconds to jump per key press

  if (e.key === "ArrowLeft") {
    // move time backward
    let t = parseFloat(timeSlider.value) || 0;
    t = Math.max(0, t - step);
    timeSlider.value = t;

    // if music is playing, restart audio at new time
    if (isPlaying) seekToTime(t);

    e.preventDefault();
  }

  if (e.key === "ArrowRight") {
    // move time forward
    let t = parseFloat(timeSlider.value) || 0;
    t = Math.min(audioBuffer.duration, t + step);
    timeSlider.value = t;

    if (isPlaying) seekToTime(t);

    e.preventDefault();
  }
    });

    // rendering
    function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // draw lanes
      laneWidth = canvas.width / lanes;
      for (let i=0;i<lanes;i++){
        ctx.fillStyle = i%2 ? '#12171b' : '#0f1417';
        ctx.fillRect(i*laneWidth,0,laneWidth,canvas.height);
        if (i===0) ctx.save();
        if (i===lanes-1) ctx.restore();
        // lane separator
        ctx.strokeStyle = '#1f2933'; ctx.lineWidth = 1; ctx.strokeRect(i*laneWidth,0,laneWidth,canvas.height);
      }
      // highlight active lane if selecting
      // draw hit line
      ctx.fillStyle = '#222'; ctx.fillRect(0, hitY, canvas.width, 6);

      // draw notes: determine current song time
      const now = (isPlaying && audioStartTime !== null) ? (audioContext.currentTime - audioStartTime) : parseFloat(timeSlider.value) || 0;
      // update slider if playing
      if (isPlaying && audioBuffer){
        timeSlider.value = Math.min(audioBuffer.duration, now).toFixed(3);
      }
      timeDisplay.textContent = (+now).toFixed(3)+'s';

      // Miss detection simplified (editor doesn't judge as gameplay)

      // draw notes within lookahead
      for (const note of notes){
        const dt = note.time - now; if (dt > lookahead) continue; if (note.time - now < -3) continue; // skip old
        const y = hitY - dt * pixelsPerSecond;
        const x = note.lane * laneWidth + laneWidth/2;
        if (note.type === 'tap'){
          ctx.beginPath();
          ctx.fillStyle = (note===selectedNote) ? '#ffd' : '#0aa';
          ctx.arc(x,y, Math.min(22, 14 + (1 - Math.min(1, dt/ lookahead))*10),0,Math.PI*2);
          ctx.fill();
          ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.font='12px sans-serif'; ctx.fillText(note.lane, x-6, y+4);
        } else if (note.type === 'hold'){
          const endTime = note.time + (note.duration||0);
          const endDt = endTime - now; const yEnd = hitY - endDt * pixelsPerSecond;
          // tail
          ctx.beginPath();
          ctx.lineWidth = 14; ctx.lineCap='round';
          ctx.strokeStyle = (note===selectedNote) ? 'rgba(255,215,0,0.9)' : 'rgba(10,170,170,0.5)';
          ctx.moveTo(x, y);
          ctx.lineTo(x, yEnd);
          ctx.stroke();
          // head
          ctx.beginPath(); ctx.fillStyle = (note===selectedNote) ? '#ffd' : '#0aa'; ctx.arc(x,y, 16,0,Math.PI*2); ctx.fill();
          // tail end
          ctx.beginPath(); ctx.fillStyle = '#066'; ctx.arc(x,yEnd, 8,0,Math.PI*2); ctx.fill();
        }
      }

      // draw temp create note if exists
      if (createTemp){
        const now2 = (isPlaying && audioStartTime !== null) ? (audioContext.currentTime - audioStartTime) : parseFloat(timeSlider.value) || 0;
        const dt = createTemp.time - now2; const y = hitY - dt * pixelsPerSecond;
        const endY = hitY - (createTemp.time + createTemp.duration - now2) * pixelsPerSecond;
        const x = createTemp.lane * laneWidth + laneWidth/2;
        ctx.beginPath(); ctx.lineWidth = 12; ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.moveTo(x,y); ctx.lineTo(x,endY); ctx.stroke();
        ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(x,y,12,0,Math.PI*2); ctx.fill();
      }

      requestAnimationFrame(render);
    }

    render();

    // expose some helper to console for quick debug
    window._editor = {notes, audioBuffer, audioContext, startAudioAt};

  })();
  </script>
</body>
</html>